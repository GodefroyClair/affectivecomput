radar_theme %+%
ggtitle(paste(base_titre, "(radar)"))
#bar
ggplot(melted_radar, aes(x = variable, y = value, fill = variable)) %+%
facet_wrap( ~ group, ncol = 30)  %+%
geom_bar(stat="identity",position="dodge",width=.5) %+%
ylim(0,1) %+%
geom_text(aes(x = 2.5, y = 1.1, label = lab_rep), colour="black", size = 2, inherit.aes=F) %+%
radar_theme %+%
ggtitle(paste(base_titre, "(ligne)"))
#==========================================#
## Carte des données captées par neurones ##
#==========================================#
#création d'un nouveau df montrant le nombre de données associées à chaque référent
#attention : certaines neurones peuvent ne pas avoir de données associées...
#on prend le df qui a servi au som
df_ref <- df_stat_scale_scale #inutile ??
#on ajoute experience
df_ref$nom_experience <- df_selec$nom.experience
#et id_neurone
df_ref$id_neurone <- som1$unit.classif
#on retire le superflu, on regroupe par pair id_neurone associé - nom_experience...
#...et on compte le nombre de données associé à chaque pair
df_count_neuro_expe <- df_ref %>% select(id_neurone, nom_experience) %>%
group_by(id_neurone, nom_experience) %>% summarise(count = n())
#on utilise tidyr::spread pour que chaque expe est sa colonne
expe_par_neurone <- df_count_neuro_expe %>% spread(nom_experience, count, fill = 0)
#reste algo précédent
#expe_par_neurone <- as.data.frame(with(df_ref,
#                                       tapply(row.names(df_selec),
#                                              list(neurone=id_neurone,experience=nom.experience),
#                                              length)))
#ajoutons les neurones manquants
#liste des neurones non présents
list_neuro_vid <- which(!seq(1:900) %in% as.numeric(expe_par_neurone$id_neurone))
nb_neuro_vid <- length(list_neuro_vid)
#df des neurones manquants
df_neuro_vid <- as.data.frame(matrix(nrow=nb_neuro_vid,ncol = ncol(expe_par_neurone)))
#prépa du rbind avec autre fdf
rownames(df_neuro_vid) <- list_neuro_vid
colnames(df_neuro_vid) <- colnames(expe_par_neurone)
df_neuro_vid$id_neurone <- list_neuro_vid
df_neuro_vid[is.na(df_neuro_vid)] <- 0
#bind_rows (not rbind !) & mis en ordre
expe_par_neurone <- bind_rows(expe_par_neurone,df_neuro_vid)
expe_par_neurone <- expe_par_neurone %>% arrange(id_neurone)
#nom de l'experience la plus représentée par neurones
expe_major_par_neurone <- as.factor(colnames(expe_par_neurone[-1])[max.col(expe_par_neurone[-1])])
#put NA in line of neurone empty
expe_major_par_neurone[rowSums(expe_par_neurone)==0]<-NA
#test <- as.factor(rep(c("AB","CW","DA"),300))
#plot(som1, type = "property", property = as.numeric(test), main="expérience majoritaire par neurone")
#representation graphique de l'expérience majoritaire par neurones :
plot(som1, type = "property", property = as.numeric(expe_major_par_neurone), main="",  heatkey =F,palette.name=coolBlueHotRed)
text(x=som1$grid$pts[,1],y=som1$grid$pts[,2],labels=expe_major_par_neurone,cex = .5,font=2)
## Graph des répartitions entre expériences par neurones
nb_group <- 300
nb_expe <- 8
base_rep <- 1:nb_group
rep <- rep("", nb_expe - 1)
lab_rep <- purrr::map(base_rep, function(ele) { c(ele, rep)}) %>% unlist()
# reprendre code pour recup expe_par_neurone
expe_par_neurone <- expe_par_neurone %>% head(nb_group)
#expe_par_neurone$groups <- as.numeric(expe_par_neurone$groups)
#expe_par_neurone %>% filter(groups == 15)
#melted_expe_par_n <- melt(expe_par_neurone, id = "id_neurone") %>%
#  group_by(id_neurone) %>% mutate(cumsum = cumsum(value)) %>% filter(variable != "id_neurone")
gathered_expe_par_n <- expe_par_neurone %>% gather(variable, value, -id_neurone) %>%
group_by(id_neurone) %>% mutate(cumsum = cumsum(value))
gathered_expe_par_n %>% filter(id_neurone == 15)
expe_neuro_theme <-  theme(panel.margin.x = unit(0, "lines"), panel.margin.y = unit(0, "lines"), panel.border = element_rect(colour = rgb(1.0, 0, 0, 0.5), fill=NA, size=1),
axis.text.x=element_text(size = 6),
axis.title.y=element_blank(), axis.text.y=element_text(size = 8), axis.ticks.y=element_blank(),
strip.background = element_blank(), strip.text.x = element_blank(),
legend.title = element_text(colour="black", size = 5,  face="bold"),
legend.text = element_text(colour="black", size = 5),
legend.key = element_rect(size = 1),
title = element_text(color = "blue", size = 6, face = "bold"))
expe_neuro_theme2 <- theme(axis.text.y = element_text(size = 3, margin = margin(0, 0, 0, 0)))
ggplot(gathered_expe_par_n, aes(x = as.factor(id_neurone), y = value, fill = factor(variable))) %+%
geom_bar(stat = "identity") %+%
#geom_text(aes(x = group + .2, y = cumsum - 15, label = value), size = 3, colour = "black", check_overlap = TRUE) %+%
geom_text(aes(x = id_neurone - 0, y = (cumsum + cumsum - value)/2, label = ifelse(value != 0, as.character(variable), "")), size = 3, colour = "black", check_overlap = FALSE) %+%
expe_neuro_theme %+%
ggtitle("expériences captées")
ggplot(gathered_expe_par_n, aes(x = id_neurone, y = value, fill = factor(variable))) %+%
geom_bar(stat = "identity", position = "fill") %+%
#geom_text(aes(y = cumsum - 15, label = value), colour = "black") %+%
expe_neuro_theme %+%
ggtitle("expériences captées")
ggplot(gathered_expe_par_n, aes(x = variable, y = value, fill = variable)) %+%
facet_wrap( ~ id_neurone, ncol = 30, scales = "free")  %+%
geom_bar(stat="identity") %+%
#geom_text(aes(x = 2.5, y = 1, label = lab_rep), colour="black", size = 2, inherit.aes=F) %+%
expe_neuro_theme %+%
ggtitle("expériences captées")
### Carte des temporalités captées par neurones
#traiter à part les données pour les expériences "2" (ie PCo2, PCo3)
#on prend le df général
df_sec <- as.data.table(df_selec)
#on crée une var de facteur par secondes (arbitraire ??)
df_sec$one_sec_elapsed <- df_selec$tps.ecoule %>% round(digits = 0) %>% factor()
df_sec$five_sec_elapsed <- df_selec$tps.ecoule %>% `/`(5)  %>% round(digits = 0) %>% factor()
#on ajoute id_neurone
df_sec$id_neurone <- som1$unit.classif
## Table of the time per neurones
#on retire les expe qui finissent pas 2 ou 3
#df_sec <- df_sec %>% filter(!grepl("*[2|3]",nom.experience))
#on retire le superflu, on regroupe par pair id_neurone - sec_elapsed...
#...et on compte le nombre de données associé à chaque pair
df_neuro_sec <- df_sec %>% select(id_neurone, one_sec_elapsed, nom.experience)
df_neuro_5sec <- df_sec %>% select(id_neurone, five_sec_elapsed, nom.experience)
df_count_neuro_1sec <- df_neuro_sec %>%
group_by(id_neurone, one_sec_elapsed, nom.experience) %>% summarise(count = n())
df_count_neuro_5sec <- df_neuro_5sec %>%
group_by(id_neurone, five_sec_elapsed, nom.experience) %>% summarise(count = n())
#on utilise tidyr::spread pour que chaque expe est sa colonne
expe_par_sec <- df_count_neuro_1sec %>% spread(nom.experience, count, fill = 0)
expe_par_5sec <- df_count_neuro_5sec %>% spread(nom.experience, count, fill = 0)
## table of the neurones graphs according to time
dt_neur_coord <- data.table(id_neurones = 1:900, x = som1$grid$pts[,1], y = som1$grid$pts[,2])
#create a data table that for each experience shows the neurone path in the data and the time spent in each neurone
chg_neur <- df_sec$id_neurone != lag(df_sec$id_neurone) | df_sec$nom.experience != lag(df_sec$nom.experience)
chg_neur[1] <- T
path_neur <- df_sec$id_neurone[chg_neur]
nom_expe <- df_sec$nom.experience[chg_neur]
#no change : 1 as long as the referent is not changing
no_chg <- as.numeric(!chg_neur)
#reduce the no change vec into a vector that counts the length of each series of no change
nb_data <- no_chg %>% purrr::reduce( function(prev, cur) { if(cur == 1) {prev[length(prev)] <- prev[length(prev)] + 1 ; prev } else{ prev[length(prev)+1] <- 1; prev }}, 1)
#creata a dt
dt_path_neur <- data.table(path_neur, nom_expe, nb_data)
dt_path_neur <- bind_cols(dt_path_neur,as.data.frame(dt_neur_coord[dt_path_neur$path_neur,.(x,y)]))
#next neurone coordinates
#let first of each experience at na ??
new_expe <- dt_path_neur$nom_expe != lag(dt_path_neur$nom_expe)
dt_path_neur$xend <- lag(dt_path_neur$x, default = dt_path_neur$x[1])
dt_path_neur$yend <- lag(dt_path_neur$y, default = dt_path_neur$y[1])
#new graph of the neurones
ggplot(dt_neur_coord, aes(x = x, y = y)) + geom_point( col = "blue", shape = 21)
ggplot(dt_path_neur, aes(x = x, y = y)) %+% geom_point(aes(col = nom_expe, size = nb_data), alpha = 0.5)
#graph with neurones color given according to the experience attached to it (add a little jitter to help with overlap)
ggplot(dt_path_neur, aes(x = x, y = y)) %+% geom_jitter(aes(col = nom_expe), width = 0.5, height = 0.5, alpha = 0.5)
test_AB <- dt_path_neur %>% filter(nom_expe == "AB") %>% dplyr::mutate(elapsed_time = cumsum(nb_data)) %>% data.table
ggplot(test_AB, aes(x = x, y = y)) %+%
geom_point(col = "darkgrey")  %+%
geom_segment(aes(xend = xend, yend = yend, col = elapsed_time), alpha = .5, arrow = arrow(length = unit(0.02, "npc"))) %+%
scale_color_gradient2(mid = "blue", high = "red")
dt_path_neur <- dt_path_neur %>% group_by(nom_expe) %>% mutate(elapsed_time = cumsum(nb_data)) %>% data.table()
cbPalette <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
ggplot(dt_path_neur, aes(x = x, y = y)) %+%
ggplot2::facet_wrap(facets =  ~ nom_expe) %+%
scale_color_manual(values = cbPalette) %+%
geom_point(aes(col = nom_expe))
graph_path_neurons <- function(df) {
#colors & theme
cbPalette2 <- c("#F00000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
simple_theme <- theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"))
gg <-  ggplot(df, aes(x = x, y = y)) %+%
facet_wrap(facets =  ~ nom_expe) %+%
geom_segment(aes(xend = xend, yend = yend, col = elapsed_time), alpha = .5, arrow = arrow(length = unit(0.05, "npc"))) %+%
scale_color_gradient2(mid = "grey87", high = "grey27") %+%
geom_point(aes(fill = nom_expe, size = nb_data), shape = 21) %+%
scale_fill_manual(values = cbPalette2) %+%
simple_theme %+%
ggtitle("déplacement des données entre les référents")
print(gg)
}
dt_path_short <- dt_path_neur %>% filter(elapsed_time < 10000)
graph_path_neurons(dt_path_short)
dt_path_short2 <- dt_path_neur %>% filter(elapsed_time >= 10000 & elapsed_time < 20000)
graph_path_neurons(dt_path_short2)
dt_path_short3 <- dt_path_neur %>% filter(elapsed_time >= 20000 & elapsed_time < 30000)
graph_path_neurons(dt_path_short3)
dt_path_short4 <- dt_path_neur %>% filter(elapsed_time >= 30000 & elapsed_time < 40000)
graph_path_neurons(dt_path_short4)
pca <- prcomp(df_stat_scale_scale, center = T, scale =T)
colnames(dt_stat_scale_scale)
colnames(df_stat_scale_scale)
pca <- df_stat_scale_scale_ %>% select(-nom.experience, -loess)
df_pca <- df_stat_scale_scale_ %>% select(-nom.experience, -loess)
pca <- prcomp(df_pca, center = T, scale =T)
df_pca <- df_stat_scale_scale_ %>% select(-nom.experience, -loess)
df_pca <- df_stat_scale_scale %>% select(-nom.experience, -loess)
pca <- prcomp(df_pca, center = T, scale =T)
str(pca)
print(pca)
summary(pca)
plot(pca, type = "l")
ggplot(pca, aes(x = , y = )) + geom_line()
library(devtools)
install_github("ggbiplot", "vqv")
library(ggbiplot)
g <- ggbiplot(ir.pca, obs.scale = 1, var.scale = 1,
groups = ir.species, ellipse = TRUE,
circle = TRUE)
g <- g + scale_color_discrete(name = '')
g <- g + theme(legend.direction = 'horizontal',
legend.position = 'top')
print(g)
g <- ggbiplot(ir.pca, obs.scale = 1, var.scale = 1,
groups = ir.species, ellipse = TRUE,
circle = TRUE)
g <- g + scale_color_discrete(name = '')
plot_signal <- function(df) {
ggplot(data = df) + geom_line(aes(x= date, y = respi_clean_hl), color = "blue") +
geom_smooth(method="loess", formula = y ~ x, se=TRUE, size= 1, span=.2, color = "green")  +
geom_line(aes(x = date, y = loess ), color = "green")  +
geom_line(aes(x = date, y = max_per_period), color = "red") +
geom_line(aes(x = date, y = min_per_period), color = "purple") +
geom_text(aes(x = date, y = max_per_period, label= period_duration), check_overlap = TRUE) +
ggtitle(df$nom.experience)
}
get_expe <- get_expe_base(df_all)
plot_signal(get_expe("AB")[1000:10000,])
plot_signal(get_expe("CLP")[1000:10000,])
plot_signal(get_expe("CW")[1000:10000,])
plot_signal(get_expe("DA")[1000:10000,])
plot_signal(get_expe("DA2")[1000:10000,])
plot_signal(get_expe("DA3")[1000:10000,])
plot_signal(get_expe("DE")[1000:10000,])
plot_signal(get_expe("PCo")[1000:10000,])
plot_signal(get_expe("PCo2")[1000:10000,])
plot_signal(get_expe("PCo3")[1000:10000,])
som1 <- kohonen::som(data = as.matrix(df_SOM_scale_scale), grid = somgrid(30, 30, "hexagonal"), rlen=180, alpha =c(4,0.0001))
df_SOM_scale_scale <-  df_stat_scaled_per_exp %>% dplyr::select(-nom.experience) %>% scale() %>% data.frame()
colnames(df_SOM_scale_scale)
plot(som1, type = "property", property = som1$codes[,7], main="carte heatmap de frequence", palette.name=coolBlueHotRed)
par(xpd=F)
par(mai=  c(0, 0, 0, 0))
plot(som1, type = "property", property = som1$codes[,9], main="carte heatmap de ", palette.name=coolBlueHotRed)
par(xpd=F)
par(mai=  c(0, 0, 0, 0))
plot(som1, type = "property", property = som1$codes[,9], main="carte heatmap de ", palette.name=coolBlueHotRed)
plot(som1, type = "property", property = som1$codes[,7], main="carte heatmap de min", palette.name=coolBlueHotRed)
plot(som1, type = "property", property = som1$codes[,8], main="carte heatmap de frequence", palette.name=coolBlueHotRed)
plot(som1, type = "property", property = som1$codes[,9], main="carte heatmap de ", palette.name=coolBlueHotRed)
df_SOM_scale_scale <-  df_stat_scaled_per_exp %>% dplyr::select(-nom.experience, -loess) %>% scale() %>% data.frame()
som2 <- kohonen::som(data = as.matrix(df_SOM_scale_scale), grid = somgrid(10, 10, "hexagonal"), rlen=180, alpha =c(4,0.0001))
som2 <- kohonen::som(data = as.matrix(df_SOM_scale_scale), grid = somgrid(10, 10, "hexagonal"), rlen=180, alpha =c(10,0.0001))
som2 <- kohonen::som(data = as.matrix(df_SOM_scale_scale), grid = somgrid(10, 10, "hexagonal"), rlen=180, alpha =c(10,0.0001))
som2 <- kohonen::som(data = as.matrix(df_SOM_scale_scale), grid = somgrid(10, 10, "hexagonal"), rlen=180, alpha =c(4,0.0001))
som2 <- kohonen::som(data = as.matrix(df_SOM_scale_scale), grid = somgrid(10, 10, "hexagonal"), rlen=180, alpha =c(3,0.0001))
som2 <- kohonen::som(data = as.matrix(df_SOM_scale_scale), grid = somgrid(10, 10, "hexagonal"), rlen=180, alpha =c(2,0.0001))
i <- 1:60
x <- 1:120
y <- c(rep(1,60),1/i)
save(som1,file = "./data/som1.RDa")
par(xpd=F)
par(mai=  c(0, 0, 0, 0))
#ajout d'itération et une descente de temp plus smooth
plot(som2, main = "", type="codes",labels = NULL)
plot(som2, type="changes", main="carte du progrès d'apprentissage")
plot(som2, type="count", main= "carte de comptages des données captées")
plot(som2, type="quality", palette.name = coolBlueHotRed, main = "carte de \"qualité\" : distance moyenne des données aux neurones")
som2$grid$n.hood
som2$grid$topo
som2$codes
som2$method
som2$distances
som2$toroidal
som2$radius
colnames(df_SOM_scale_scale)
plot(som2, type = "property", property = som1$codes[,1], main="carte heatmap de l'activité électrodermale", palette.name=coolBlueHotRed)
plot(som2, type = "property", property = som1$codes[,2], main="carte heatmap de temperature", palette.name=coolBlueHotRed)
plot(som2, type = "property", property = som1$codes[,3], main="carte heatmap de freq card", palette.name=coolBlueHotRed)
plot(som2, type = "property", property = som1$codes[,4], main="carte heatmap de respi nettoyée", palette.name=coolBlueHotRed)
plot(som2, type = "property", property = som1$codes[,5], main="carte heatmap de trend", palette.name=coolBlueHotRed)
plot(som2, type = "property", property = som1$codes[,6], main="carte heatmap de max par periode", palette.name=coolBlueHotRed)
plot(som2, type = "property", property = som1$codes[,7], main="carte heatmap de min par periode", palette.name=coolBlueHotRed)
plot(som2, type = "property", property = som1$codes[,8], main="carte heatmap de frequence", palette.name=coolBlueHotRed)
df_codes <- data.frame(som2$codes) %>% add_rownames(var = "group")  %>%
mutate_each(funs(rescale), -group)  %>% head(nb_group)
#group needs to be numeric
df_codes$group <- as.numeric(df_codes$group)
# to be able to use geom_bar we need to untidy the data
melted_radar <- melt(df_codes, id = "group")
base_rep <- 1:nb_group
rep <- rep("", nb_var - 1)
lab_rep <- purrr::map(base_rep, function(ele) { c(ele, rep)}) %>% unlist()
#ann_text <- data.frame(x=1.25, y=5, lab = as.character(lab_rep))
#titre des graphiques
base_titre <- "Carte d'identité des référents"
#theme that are used for the multiradar plot
radar_theme <-  theme(panel.margin.x = unit(0, "lines"), panel.margin.y = unit(0, "lines"), panel.border = element_rect(colour = rgb(1.0, 0, 0, 0.5), fill=NA, size=1),
axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
axis.title.y=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank(),
strip.background = element_blank(), strip.text.x = element_blank(),
legend.title = element_text(colour="black", size=5,  face="bold"),
legend.text = element_text(colour="black", size=5),
legend.key = element_rect(size = 1),
title = element_text(color = "blue", size =6, face = "bold"))
#length
ggplot(melted_radar, aes(x = variable, y = value, fill = variable)) %+%
facet_wrap( ~ group, ncol = 30)  %+%
geom_bar(stat="identity",position="dodge") %+%
ylim(0,1) %+%
geom_text(aes(x = 1.5, y = 1, label = lab_rep), colour="black", size = 1, inherit.aes=F) %+%
coord_polar(start = 0)  %+%
radar_theme %+%
ggtitle(paste(base_titre, "(longueur)"))
nb_group <- 100
nb_var <- 8
#make a df with the value of the variables associated with each neurone and the id of the neurone (group)
#it is easier to rescale everythng to ratio ([0-1]) with rescale
mutate_each(funs(rescale), -group)  %>% head(nb_group)
df_codes <- data.frame(som1$codes) %>% add_rownames(var = "group")  %>%
#group needs to be numeric
df_codes$group <- as.numeric(df_codes$group)
# to be able to use geom_bar we need to untidy the data
melted_radar <- melt(df_codes, id = "group")
#we build the label such that each facetted graph has a number associated to it
##!! this is a patch, there must be a way to do this BETTER !!
base_rep <- 1:nb_group
rep <- rep("", nb_var - 1)
lab_rep <- purrr::map(base_rep, function(ele) { c(ele, rep)}) %>% unlist()
#ann_text <- data.frame(x=1.25, y=5, lab = as.character(lab_rep))
#titre des graphiques
base_titre <- "Carte d'identité des référents"
#theme that are used for the multiradar plot
radar_theme <-  theme(panel.margin.x = unit(0, "lines"), panel.margin.y = unit(0, "lines"), panel.border = element_rect(colour = rgb(1.0, 0, 0, 0.5), fill=NA, size=1),
axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
axis.title.y=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank(),
strip.background = element_blank(), strip.text.x = element_blank(),
legend.title = element_text(colour="black", size=5,  face="bold"),
legend.text = element_text(colour="black", size=5),
legend.key = element_rect(size = 1),
title = element_text(color = "blue", size =6, face = "bold"))
#limit the nb of neurones we are working on to fasten the graph making process
#nb_group has to be 300 in the end
nb_group <- 100
nb_var <- 8
#make a df with the value of the variables associated with each neurone and the id of the neurone (group)
#it is easier to rescale everythng to ratio ([0-1]) with rescale
df_codes <- data.frame(som1$codes) %>% add_rownames(var = "group")  %>%
mutate_each(funs(rescale), -group)  %>% head(nb_group)
#group needs to be numeric
df_codes$group <- as.numeric(df_codes$group)
# to be able to use geom_bar we need to untidy the data
melted_radar <- melt(df_codes, id = "group")
#we build the label such that each facetted graph has a number associated to it
##!! this is a patch, there must be a way to do this BETTER !!
base_rep <- 1:nb_group
rep <- rep("", nb_var - 1)
lab_rep <- purrr::map(base_rep, function(ele) { c(ele, rep)}) %>% unlist()
#ann_text <- data.frame(x=1.25, y=5, lab = as.character(lab_rep))
#titre des graphiques
base_titre <- "Carte d'identité des référents"
#theme that are used for the multiradar plot
radar_theme <-  theme(panel.margin.x = unit(0, "lines"), panel.margin.y = unit(0, "lines"), panel.border = element_rect(colour = rgb(1.0, 0, 0, 0.5), fill=NA, size=1),
axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
axis.title.y=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank(),
strip.background = element_blank(), strip.text.x = element_blank(),
legend.title = element_text(colour="black", size=5,  face="bold"),
legend.text = element_text(colour="black", size=5),
legend.key = element_rect(size = 1),
title = element_text(color = "blue", size =6, face = "bold"))
#length
ggplot(melted_radar, aes(x = variable, y = value, fill = variable)) %+%
facet_wrap( ~ group, ncol = 30)  %+%
geom_bar(stat="identity",position="dodge") %+%
ylim(0,1) %+%
geom_text(aes(x = 1.5, y = 1, label = lab_rep), colour="black", size = 1, inherit.aes=F) %+%
coord_polar(start = 0)  %+%
radar_theme %+%
ggtitle(paste(base_titre, "(longueur)"))
df_codes <- data.frame(som2$codes) %>% add_rownames(var = "group")  %>%
mutate_each(funs(rescale), -group)  %>% head(nb_group)
#group needs to be numeric
df_codes$group <- as.numeric(df_codes$group)
# to be able to use geom_bar we need to untidy the data
melted_radar <- melt(df_codes, id = "group")
#we build the label such that each facetted graph has a number associated to it
##!! this is a patch, there must be a way to do this BETTER !!
base_rep <- 1:nb_group
rep <- rep("", nb_var - 1)
lab_rep <- purrr::map(base_rep, function(ele) { c(ele, rep)}) %>% unlist()
#ann_text <- data.frame(x=1.25, y=5, lab = as.character(lab_rep))
#titre des graphiques
base_titre <- "Carte d'identité des référents"
#theme that are used for the multiradar plot
radar_theme <-  theme(panel.margin.x = unit(0, "lines"), panel.margin.y = unit(0, "lines"), panel.border = element_rect(colour = rgb(1.0, 0, 0, 0.5), fill=NA, size=1),
axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(),
axis.title.y=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank(),
strip.background = element_blank(), strip.text.x = element_blank(),
legend.title = element_text(colour="black", size=5,  face="bold"),
legend.text = element_text(colour="black", size=5),
legend.key = element_rect(size = 1),
title = element_text(color = "blue", size =6, face = "bold"))
#length
ggplot(melted_radar, aes(x = variable, y = value, fill = variable)) %+%
facet_wrap( ~ group, ncol = 30)  %+%
geom_bar(stat="identity",position="dodge") %+%
ylim(0,1) %+%
geom_text(aes(x = 1.5, y = 1, label = lab_rep), colour="black", size = 1, inherit.aes=F) %+%
coord_polar(start = 0)  %+%
radar_theme %+%
ggtitle(paste(base_titre, "(longueur)"))
ggplot(melted_radar, aes(x = variable, y = value, fill = variable)) %+%
facet_wrap( ~ group, ncol = 10)  %+%
geom_bar(stat="identity",position="dodge") %+%
ylim(0,1) %+%
geom_text(aes(x = 1.5, y = 1, label = lab_rep), colour="black", size = 1, inherit.aes=F) %+%
coord_polar(start = 0)  %+%
radar_theme %+%
ggtitle(paste(base_titre, "(longueur)"))
som1$radius
som2$radius
matrix(c(1,1,-2,1), ncol =2 )
matrix(c(1,-2,1,1), ncol =2 )
i = matrix(c(1,-2,1,1), ncol =2 )
x = matrix(c(2,1,1,0), ncol =2 )
i*x
i = matrix(c(0,1,1,-2), ncol =2 )
i*x
x*i
i = matrix(c(0,1,1,-2), ncol =2 )
i
x
x*i
x*i
transpose(c(2,1))
transpose(list(2,1))
t(c(2,1))
matrix(t(c(2,1)),t(1,0)
matrix(t(c(2,1)),t(1,0))
matrix(t(c(2,1)),t(1,0)))
matrix(t(c(2,1)),t(c(1,0)))
matrix(t(2,1),t(c(1,0)))
matrix(t(c(2,1)),t(c(1,0)))
m
x
eigen(x)
x
x
m
i
m <- matrix(c(2,1,1,0),col =2)
m <- matrix(2,1,1,0,col =2)
m <- matrix(c(2,1,1,0),col = 2)
m <- matrix(c(2,1,1,0),ncol = 2)
m
eigen(m)
i <- matrix(c(1,-2,1,1),ncol = 2)
i
j <- matrix(c(0,1,1,_2),ncol = 2)
j <- matrix(c(0,1,1,)2),ncol = 2)
j <- matrix(c(0,1,1,)2),ncol = 2)
j <- matrix(c(0,1,1,-2),ncol = 2)
i*m
j*m
j*m
j
j*m
j
m
id
diag(1,nrow=2)
id2 <-diag(1,nrow=2)
x =1
m - x* id2
m + x* id2
m _1 x* id2
m _-1 x* id2
m -1 x* id2
eigen(m)
x
m -2.41 x* id2
m - 2.41* id2
m + 2.41* id2
eigen(m)
m - 2.41* c(-0.92, -0.38)
m - 2.4142136* c(-0.9238795, -0.3826834)
m
solve(m)
solve(m)*m
u <- c(3,4)
norm(u)
norm(matrix(u))
-4:5
-4/5
c(-.8, 3/5)
dist(c(-.8, 3/5))
dist(c(-4/5, 3/5))
dist(c(-4, 3))
-4/5^2+ 3/5^2
sqrt(-(4/5)^2 + (3/5)^2)
sqrt((-4/5)^2 + (3/5)^2)
3/5
-0.8 * 3 + .6 * 4
-0.8 * 3 + 0.6 * 4
-0.8 * 3
0.6 * 4
matrix(c(1,1,1,1),c(1,1,-1,-1),c(1,-1,-1,1),c(1,-1,1,-1))
matrix(c(1,1,1,1, 1,1,-1,-1, 1,-1,-1,1,1,-1,1,-1)
)
matrix(c(1,1,1,1, 1,1,-1,-1, 1,-1,-1,1,1,-1,1,-1), ncol =4)
m1 <- matrix(c(1,1,1,1, 1,1,-1,-1, 1,-1,-1,1,1,-1,1,-1), ncol =4)
m2 <- t(m1)
m2 == =1
m2 == m1
any(m2 == m1)
any(m1 == t(m1))
eigen(m1)
m1
solve(m1)
solve(m1)*m1
solve(m1)%*%m1
solve(m1)
m1
solve(m1)
