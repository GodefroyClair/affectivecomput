min.list[2]
min.list <- unlist(extrem(min))
max.list <- unlist(extrem(max))
min.list[2]
min.list
max.list <- as.vector(unlist(extrem(max)))
min.list <- as.vector(unlist(extrem(min)))
min.list
res[above] <- max.list
res <- list()
res <- vector()
res[above] <- max.list
res <- list()
res[above] <- max.list
res <- rep(0,length(above))
res[above] <- max.list
res[above]
res
res[!above] <- max.list
res[!above] <- min.list
res
res[above] <- max.list[above]
res[!above] <- max.list[!above]
res
#find the max (respectively min) for each series of values of signal above (under) signal.loess
#then replace each value of the whole signal with the max (resp. min) of the series in its in.
signal.max.min <- function(signal, signal.loess) {
#boolean vec :check if signal is above or under the loess
above <- signal >= signal.loess
#split according to above/under
signal.split <- split(signal, cumsum(c(0, diff(above) != 0)))
#replicate the max of the sequence above loess (the min if under)@
extrem <- function(fun){
sapply(
signal.split, function(lst){
extremum <- fun(lst)
#get the max for postive and the min for negative
#replicate the length of the list
rep(extremum, length(lst))
}
)
}
max.list <- as.vector(unlist(extrem(max)))
min.list <- as.vector(unlist(extrem(min)))
res <- rep(0,length(above))
res[above] <- max.list[above]
res[!above] <- max.list[!above]
res
}
signal.max.min(data.AB$respiration[11700:11800], loess.ex$fitted[11700:11800] )
data.AB$loess <- loess(data.AB$respiration ~ as.numeric(data.AB$date), degree=1,span=.1)$fitted
data.AB$s.max.min <- signal.max.min(data.AB$respiration, loess.ex$fitted)
ggplot(data = data.AB[11750:11900,]) + geom_line(aes(x= date, y = respiration), color = "blue") +
#geom_smooth(method="loess", formula = y ~ x, se=TRUE, size= 1, span=.2, color = "green")  +
geom_line(aes(x = date, y = loess ), color = "green")  +
geom_line(aes(x = date, y = s.max.min), color = "red")
#find the max (respectively min) for each series of values of signal above (under) signal.loess
#then replace each value of the whole signal with the max (resp. min) of the series in its in.
signal.max.min <- function(signal, signal.loess) {
#boolean vec :check if signal is above or under the loess
above <- signal >= signal.loess
#split according to above/under
signal.split <- split(signal, cumsum(c(0, diff(above) != 0)))
#replicate the max of the sequence above loess (the min if under)@
extrem <- function(fun){
sapply(
signal.split, function(lst){
extremum <- fun(lst)
#get the max for postive and the min for negative
#replicate the length of the list
rep(extremum, length(lst))
}
)
}
max.list <- as.vector(unlist(extrem(max)))
min.list <- as.vector(unlist(extrem(min)))
res <- rep(0,length(above))
res[above] <- max.list[above]
res[!above] <- min.list[!above]
res
}
}
signal.max.min(data.AB$respiration[11700:11800], loess.ex$fitted[11700:11800] )
data.AB$loess <- loess(data.AB$respiration ~ as.numeric(data.AB$date), degree=1,span=.1)$fitted
data.AB$s.max.min <- signal.max.min(data.AB$respiration, loess.ex$fitted)
ggplot(data = data.AB[11750:11900,]) + geom_line(aes(x= date, y = respiration), color = "blue") +
#geom_smooth(method="loess", formula = y ~ x, se=TRUE, size= 1, span=.2, color = "green")  +
geom_line(aes(x = date, y = loess ), color = "green")  +
geom_line(aes(x = date, y = s.max.min), color = "red")
require(knitr)
require(plyr)
require(ggplot2)
require(reshape2)
require(scatterplot3d)
require(grDevices)
require(kohonen)
require(ggdendro)
require(grid)
require(zoo)
mac.gd.path <- "/Users/godot/githubRepos/"
hp.gd.path <- "C:/Users/Godefroy/githubRepos/"
if(Sys.info()['nodename']=="THIM")gd.path <- hp.gd.path else
gd.path <- mac.gd.path
data.path <- paste(gd.path,"affectiveComputing/data",sep = "/")
```
rda.save <- paste(data.path ,"data-frame-all-expe.Rda",sep = "/")
load(rda.save)
#récupérer le résultat du cluster
hcluster.save <- paste(data.path ,"hClustering.Rda",sep = "/")
load(hcluster.save)
#récupérer les résultats de l'algo sur les neurones
som1.save <- paste(data.path ,"som1.Rda",sep = "/")
load(som1.save)
#prep :
#1) select the experiences
df.selec <- df.all[!(df.all$nom.experience %in% c("FS1","LM","HL","ST")),]
list.expe.selec <- c("AB", "CLP", "CW", "DA", "PCo", "PCo2", "PCo3","DE")
#construction d'une variable numérique représentant le temps écoulé
df.selec$tps.ecoule <- as.numeric(df.selec$date)
#transltation des valeurs pour chaque expérience de manière à ce que le 1er instant soit 0.
trash <-sapply(list.expe.selec,function(nom.exp){ df.selec[df.selec$nom.experience==nom.exp,]$tps.ecoule <<- round(df.selec[df.selec$nom.experience==nom.exp,]$tps.ecoule -  min(df.selec[df.selec$nom.experience== nom.exp,]$tps.ecoule),2 )})
rm(trash)
#create new column for time past in proportion of the whole duration
df.selec$tps.ecoule.norm <- df.selec$tps.ecoule
#divsion des valeurs pour chaque expérience de manière à ce qu'elle soit compris entre 0 et 1.
trash <-sapply(list.expe.selec,function(nom.exp){ df.selec[df.selec$nom.experience==nom.exp,]$tps.ecoule.norm <<- df.selec[df.selec$nom.experience==nom.exp,]$tps.ecoule /  max(df.selec[df.selec$nom.experience== nom.exp,]$tps.ecoule) })
rm(trash)
#recupérer l'identité du neurone référent
df.selec$referent <- som1$unit.classif
```
data.AB$loess <- loess(data.AB$respiration ~ as.numeric(data.AB$date), degree=1,span=.1)$fitted
data.AB$s.max.min <- signal.max.min(data.AB$respiration, loess.ex$fitted)
ggplot(data = data.AB[1750:1900,]) + geom_line(aes(x= date, y = respiration), color = "blue") +
#geom_smooth(method="loess", formula = y ~ x, se=TRUE, size= 1, span=.2, color = "green")  +
geom_line(aes(x = date, y = loess ), color = "green")  +
geom_line(aes(x = date, y = s.max.min), color = "red")
ggplot(data = data.AB[1750:11900,]) + geom_line(aes(x= date, y = respiration), color = "blue") +
#geom_smooth(method="loess", formula = y ~ x, se=TRUE, size= 1, span=.2, color = "green")  +
geom_line(aes(x = date, y = loess ), color = "green")  +
geom_line(aes(x = date, y = s.max.min), color = "red")
data.AB$loess <- loess(data.AB$respiration ~ as.numeric(data.AB$date), degree=1,span=.1)$fitted
data.AB$s.max.min <- signal.max.min(data.AB$respiration, loess.ex$fitted)
ggplot(data = data.AB[1750:11900,]) + geom_line(aes(x= date, y = respiration), color = "blue") +
#geom_smooth(method="loess", formula = y ~ x, se=TRUE, size= 1, span=.2, color = "green")  +
geom_line(aes(x = date, y = loess ), color = "green")  +
geom_line(aes(x = date, y = s.max.min), color = "red")
ggplot(data = data.AB[0:5000,]) + geom_line(aes(x= date, y = respiration), color = "blue") +
#geom_smooth(method="loess", formula = y ~ x, se=TRUE, size= 1, span=.2, color = "green")  +
geom_line(aes(x = date, y = loess ), color = "green")  +
geom_line(aes(x = date, y = s.max.min), color = "red")
pSignal <- numeric(length(x))
for (i in seq(along=pos)) {
pSignal <- pSignal + hgt[i]/(1 + abs((x - pos[i])/wdt[i]))^4
}
df.test <- data.frame(x,pSignal)
max.df <- as.data.frame(findpeaks(pSignal))
max.df$x <- x[max.df[,2]]
ggplot(df.test, aes(x, pSignal)) +
geom_line() +
geom_point(data = max.df, aes(x, V1))
ggplot(df.test, aes(x, pSignal)) +
geom_line() +
geom_point(data = max.df, aes(x, V1))
aw.hf <- butter(1, 1/1000, type="high")
#retire les données à zeros
# clean.data <- function(df, var.to.clean){data.AW[!(var.to.clean == 0),]  }
data.AW.clean <- data.AW[!(data.AW$respiration == 0),]
#filtre passe bas pour éliminer les fréquences basses (ie périodes longues) todo : justifier 1/20
aw.lf <- butter(1, 1/75, type="low")
#eleminates noise
data.AW.clean$respiration.lf <- signal::filter(aw.lf,data.AW.clean$respiration)
#elminates trends
data.AW.clean$respiration.hf <- signal::filter(aw.hf,data.AW.clean$respiration)
data.AW.clean$respiration.hlf <- signal::filter(aw.hf,as.numeric(data.AW.clean$respiration.lf))
library(pracma)
#recheche de max
#travaille sur un échantillon
offset <- 10000
sample.AW.clean <- data.AW.clean[offset + 0: (offset + 2001),]
max.peaks.samp <- as.data.frame(findpeaks(sample.AW.clean$respiration.hlf ))
max.peaks.samp$x <- sample.AW.clean$date[max.peaks.samp[,2] ]
#with noise
max.peaks.hf.samp <- as.data.frame(findpeaks(sample.AW.clean$respiration.hf ))
max.peaks.hf.samp$x <- sample.AW.clean$date[max.peaks.hf.samp[,2] ]
ggplot(sample.AW.clean, aes(y = respiration.hlf, date)) + geom_point( color = "lightblue", alpha = .7) +
geom_point(data = max.peaks.samp, aes(x = x, y = V1), color = "blue", alpha = 1) +
geom_point(aes(y = respiration.hf), color = "pink", alpha = .5) +
geom_point(data = max.peaks.hf.samp, aes(x = x, y = V1), color = "magenta", alpha = 1, size = .9)
ggplot(data.AW.clean, aes(y = respiration.lf, date)) + geom_line( color = "blue") +
geom_line(aes(y = respiration.hlf), color = "red", alpha = .75) +
geom_line(aes(y = respiration), color = "green", alpha = .75) +
# geom_smooth(method="loess", formula = y ~ x,se=TRUE, size= 1, span=.1) +
geom_smooth(aes(y = respiration.hlf), se=TRUE, formula= y ~ poly(x,5), colour="purple") +
geom_smooth(se=TRUE, formula= y ~ poly(x,2), colour="orange", span=.1) +
geom_point(data = max.peaks, aes(x = x, y = V1))
data.AW$loess <- loess(data.AW$respiration ~ as.numeric(data.AB$date), degree=1,span=.1)$fitted
data.AW$s.max.min <- signal.max.min(data.AW$respiration, loess.ex$fitted)
ggplot(data = data.AW[0:5000,]) + geom_line(aes(x= date, y = respiration), color = "blue") +
#geom_smooth(method="loess", formula = y ~ x, se=TRUE, size= 1, span=.2, color = "green")  +
geom_line(aes(x = date, y = loess ), color = "green")  +
geom_line(aes(x = date, y = s.max.min), color = "red")
data.AW$loess <- loess(data.AW$respiration ~ as.numeric(data.AW$date), degree=1,span=.1)$fitted
data.AW$s.max.min <- signal.max.min(data.AW$respiration, loess.ex$fitted)
ggplot(data = data.AW[0:5000,]) + geom_line(aes(x= date, y = respiration), color = "blue") +
#geom_smooth(method="loess", formula = y ~ x, se=TRUE, size= 1, span=.2, color = "green")  +
geom_line(aes(x = date, y = loess ), color = "green")  +
geom_line(aes(x = date, y = s.max.min), color = "red")
data.AW$loess <- loess(data.AW$respiration ~ as.numeric(data.AW$date), degree=1,span=.1)$fitted
data.AW$s.max.min <- signal.max.min(data.AW$respiration, loess.ex$fitted)
data.AW$s.max.min <- signal.max.min(data.AW$respiration, data.AW$loess$fitted)
data.AW$loess <- loess(data.AW$respiration ~ as.numeric(data.AW$date), degree=1,span=.1)$fitted
data.AW$s.max.min <- signal.max.min(data.AW$respiration, data.AW$loess)
ggplot(data = data.AW[0:5000,]) + geom_line(aes(x= date, y = respiration), color = "blue") +
#geom_smooth(method="loess", formula = y ~ x, se=TRUE, size= 1, span=.2, color = "green")  +
geom_line(aes(x = date, y = loess ), color = "green")  +
geom_line(aes(x = date, y = s.max.min), color = "red")
ggplot(data = data.AW[0:10000,]) + geom_line(aes(x= date, y = respiration), color = "blue") +
#geom_smooth(method="loess", formula = y ~ x, se=TRUE, size= 1, span=.2, color = "green")  +
geom_line(aes(x = date, y = loess ), color = "green")  +
geom_line(aes(x = date, y = s.max.min), color = "red")
ggplot(data = data.AW[0:10000,]) + geom_line(aes(x= date, y = respiration), color = "blue") +
#geom_smooth(method="loess", formula = y ~ x, se=TRUE, size= 1, span=.2, color = "green")  +
geom_line(aes(x = date, y = loess ), color = "green")  +
geom_line(aes(x = date, y = s.max.min), color = "red")
data.AW.clean$loess <- loess(data.AW$respiration ~ as.numeric(data.AW$date), degree=1,span=.1)$fitted
data.AW.clean$s.max.min <- signal.max.min(data.AW$respiration, data.AW$loess)
ggplot(data = data.AW.clean[0:10000,]) + geom_line(aes(x= date, y = respiration), color = "blue") +
#geom_smooth(method="loess", formula = y ~ x, se=TRUE, size= 1, span=.2, color = "green")  +
geom_line(aes(x = date, y = loess ), color = "green")  +
geom_line(aes(x = date, y = s.max.min), color = "red")
data.AW.clean$loess <- loess(data.AW$respiration ~ as.numeric(data.AW$date), degree=1,span=.1)$fitted
data.AW.clean$s.max.min <- signal.max.min(data.AW$respiration, data.AW$loess)
ggplot(data = data.AW.clean[0:10000,]) + geom_line(aes(x= date, y = respiration), color = "blue") +
#geom_smooth(method="loess", formula = y ~ x, se=TRUE, size= 1, span=.2, color = "green")  +
geom_line(aes(x = date, y = loess ), color = "green")  +
geom_line(aes(x = date, y = s.max.min), color = "red")
data.AW.clean$loess <- loess(data.AW$respiration ~ as.numeric(data.AW$date), degree=1,span=.1)$fitted
data.AW.clean$s.max.min <- signal.max.min(data.AW.clean$respiration, data.AW.clean$loess)
ggplot(data = data.AW.clean[0:10000,]) + geom_line(aes(x= date, y = respiration), color = "blue") +
#geom_smooth(method="loess", formula = y ~ x, se=TRUE, size= 1, span=.2, color = "green")  +
geom_line(aes(x = date, y = loess ), color = "green")  +
geom_line(aes(x = date, y = s.max.min), color = "red")
data.AW.clean$loess <- loess(data.AW$respiration ~ as.numeric(data.AW$date), degree=1,span=.1)$fitted
data.AW.clean$s.max.min <- signal.max.min(data.AW.clean$respiration, data.AW.clean$loess)
data.AW.clean$s.max.min <- signal.max.min(data.AW.clean$respiration, data.AW.clean$loess)
data.AW.clean$loess <- loess(data.AW.clean$respiration ~ as.numeric(data.AW.clean$date), degree=1,span=.1)$fitted
data.AW.clean$s.max.min <- signal.max.min(data.AW.clean$respiration, data.AW.clean$loess)
ggplot(data = data.AW.clean[0:10000,]) + geom_line(aes(x= date, y = respiration), color = "blue") +
#geom_smooth(method="loess", formula = y ~ x, se=TRUE, size= 1, span=.2, color = "green")  +
geom_line(aes(x = date, y = loess ), color = "green")  +
geom_line(aes(x = date, y = s.max.min), color = "red")
df.half.1 <- df.all[df.all$nom.experience %in% list.half.1,]
df.half.2 <- df.all[df.all$nom.experience %in% list.half.2,]
plot.evol.par.expe(df.half.1)
plot.evol.par.expe(df.half.2)
df.apprenti <- df.all[df.all$nom.experience %in% c("AB","ST","DA","FS1","CW","AW","EZ1","GC1","IA"),]
df.apprenti.fort <- df.all[df.all$nom.experience %in% c("AB","AW","GC1","IA"),]
plot.evol.par.expe(df.apprenti,titre="diminution de tension de la ceinture")
plot.evol.par.expe(df.apprenti.fort,titre="diminution tension ceinture fort")
df.seuil2 <- df.all[df.all$nom.experience %in% c("AB","CLP","DA","DA3"),]
plot.evol.par.expe(df.seuil2,titre="Seuil bas, exemples")
df.seuil2 <- df.all[df.all$nom.experience %in% c("AB","CLP","DA","DA3"),]
plot.evol.par.expe(df.seuil2,titre="Seuil bas, exemples")
pSignal <- numeric(length(x))
for (i in seq(along=pos)) {
pSignal <- pSignal + hgt[i]/(1 + abs((x - pos[i])/wdt[i]))^4
}
pSignal <- numeric(length(x))
for (i in seq(along=pos)) {
pSignal <- pSignal + hgt[i]/(1 + abs((x - pos[i])/wdt[i]))^4
}
df.test <- data.frame(x,pSignal)
ggplot(df.test, aes(x, pSignal)) +
geom_line() +
ggplot(df.test, aes(x, pSignal)) +
geom_line()
ggplot(df.test, aes(x, pSignal)) +
geom_line()
ggplot(df.test, aes(x, pSignal)) +
geom_line()
df.test <- data.frame(x,pSignal)
ggplot(df.test, aes(x, pSignal)) +
geom_line()
df.test$X1
df.test$x
df.test <- data.frame(x,pSignal)
df.test
pSignal
fft(pSignal)
series <- c(0,1,2,3,4,3,2,1)
series.op <- - series
repet <- 4
signal <- rep(c(series, series.op),repet)
#fast loes for testing
signal.loess <- rep(rep(0,2*length(series)), repet)
expect_equal(length(signal.loess), length(signal))
#find the max (respectively min) for each series of values of signal above (under) signal.loess
#then replace each value of the whole signal with the max (resp. min) of the series in its in.
signal.max.min <- function(signal, signal.loess) {
#boolean vec :check if signal is above or under the loess
above <- signal >= signal.loess
#split according to above/under
signal.split <- split(signal, cumsum(c(0, diff(above) != 0)))
sub.signal.lst <- function(signal.seq.list) {
#replicate the max of the sequence above loess (the min if under)@
return( function(fun){
#todo : need a condition to decide fun is min or max according to above...
extremum <- fun(lst)
signal.seq.list, function(lst){
sapply(
series <- c(0,1,2,3,4,3,2,1)
series.op <- - series
repet <- 4
signal <- rep(c(series, series.op),repet)
#fast loes for testing
signal.loess <- rep(rep(0,2*length(series)), repet)
expect_equal(length(signal.loess), length(signal))
library(testthat)
series <- c(0,1,2,3,4,3,2,1)
series.op <- - series
repet <- 4
signal <- rep(c(series, series.op),repet)
#fast loes for testing
signal.loess <- rep(rep(0,2*length(series)), repet)
expect_equal(length(signal.loess), length(signal))
#find the max (respectively min) for each series of values of signal above (under) signal.loess
#then replace each value of the whole signal with the max (resp. min) of the series in its in.
signal.max.min <- function(signal, signal.loess) {
#boolean vec :check if signal is above or under the loess
above <- signal >= signal.loess
#split according to above/under
signal.split <- split(signal, cumsum(c(0, diff(above) != 0)))
#replicate the max of the sequence above loess (the min if under)@
sub.signal.lst <- function(signal.seq.list) {
return( function(fun){
sapply(
signal.seq.list, function(lst){
#todo : need a condition to decide fun is min or max according to above...
extremum <- fun(lst)
#get the max for postive and the min for negative
#replicate the length of the list
rep(extremum, length(lst))
}
)#end sapply
}
)#end anonymous extremum function
}
extremum <- sub.signal.lst(signal.split)
max.lsts.lst <- extremum(max)
min.lsts.lst <- extremum(minu)
#unwrap the list of lists
max.list <- as.vector(unlist(max.lsts.lst))
min.list <- as.vector(unlist(min.lsts.lst))
res <- rep(0,length(above))
res[above] <- max.list[above]
res[!above] <- min.list[!above]
res
}
signal.max.min(signal, signal.loess)
signal.max.min(signal, signal.loess)
signal.max.min <- function(signal, signal.loess) {
#boolean vec :check if signal is above or under the loess
above <- signal >= signal.loess
#split according to above/under
sub.signal.lst <- function(signal.seq.list) {
#replicate the max of the sequence above loess (the min if under)@
signal.split <- split(signal, cumsum(c(0, diff(above) != 0)))
return( function(fun){
sapply(
signal.seq.list, function(lst){
#todo : need a condition to decide fun is min or max according to above...
extremum <- fun(lst)
#get the max for postive and the min for negative
#replicate the length of the list
rep(extremum, length(lst))
}
)#end anonymous extremum function
}
)#end sapply
}
extremum <- sub.signal.lst(signal.split)
max.lsts.lst <- extremum(max)
#unwrap the list of lists
min.lsts.lst <- extremum(min)
max.list <- as.vector(unlist(max.lsts.lst))
min.list <- as.vector(unlist(min.lsts.lst))
res <- rep(0,length(above))
res[above] <- max.list[above]
res[!above] <- min.list[!above]
res
}
signal.max.min(signal, signal.loess)
signal.max.min(signal, signal.loess)
above <- signal >= signal.loess
#split according to above/under
signal.split <- split(signal, cumsum(c(0, diff(above) != 0)))
#replicate the max of the sequence above loess (the min if under)@
sub.signal.lst <- function(signal.seq.list) {
return( function(fun){
sapply(
signal.seq.list, function(lst){
#todo : need a condition to decide fun is min or max according to above...
extremum <- fun(lst)
#get the max for postive and the min for negative
#replicate the length of the list
rep(extremum, length(lst))
}
)#end sapply
}
)#end anonymous extremum function
}
extremum <- sub.signal.lst(signal.split)
max.lsts.lst <- extremum(max)
min.lsts.lst <- extremum(min)
#unwrap the list of lists
max.list <- as.vector(unlist(max.lsts.lst))
min.list <- as.vector(unlist(min.lsts.lst))
res <- rep(0,length(above))
res[above] <- max.list[above]
res[!above] <- min.list[!above]
res
}
signal.max.min(signal, signal.loess)
signal.max.min(signal, signal.loess)
library(pracma)
library(ggplot2)
library(stats)
library(stringr)
library(testthat)
x <- seq(0, 1, len = 1024)
series <- c(0,1,2,3,4,3,2,1)
series.op <- - series
repet <- 4
my.signal <- rep(c(series, series.op),repet)
#fast loes for testing
my.signal.loess <- rep(rep(0,2*length(series)), repet)
expect_equal(length(my.signal.loess), length(my.signal))
#find the max (respectively min) for each series of values of signal above (under) signal.loess
#then replace each value of the whole signal with the max (resp. min) of the series in its in.
signal.max.min <- function(signal, signal.loess) {
#boolean vec :check if signal is above or under the loess
above <- signal >= signal.loess
#split according to above/under
signal.split <- split(signal, cumsum(c(0, diff(above) != 0)))
#replicate the max of the sequence above loess (the min if under)@
sub.signal.lst <- function(signal.seq.list) {
return( function(fun){
sapply(
signal.seq.list, function(lst){
#todo : need a condition to decide fun is min or max according to above...
extremum <- fun(lst)
#get the max for postive and the min for negative
#replicate the length of the list
rep(extremum, length(lst))
}
)#end sapply
}
)#end anonymous extremum function
}
extremum <- sub.signal.lst(signal.split)
max.lsts.lst <- extremum(max)
min.lsts.lst <- extremum(min)
#unwrap the list of lists
max.list <- as.vector(unlist(max.lsts.lst))
min.list <- as.vector(unlist(min.lsts.lst))
res <- rep(0,length(above))
res[above] <- max.list[above]
res[!above] <- min.list[!above]
res
}
signal.max.min(my.signal, my.signal.loess)
typeof(null)
typeof(Null)
typeof(NULL)
typeof(NA)
typeof(letters)
typeof(1)
typeof(c(1,2,3)
typeof(c(1,2,3))
typeof(c(1,2,3))
typeof(c3)
typeof(3)
typeof(1:10
)
typeof(NULL)
typeof(c(NULL))
NULL = c(NULL)
NULL == c(NULL)
1 == c(1)
1 == c(1?2)
1 == c(1,2)
l = list(a = c(1:3), b = "a string", c = pi, d = list(-1, -5))
l
l = list(c(1:3), "a string", pi, list(-1, -5))
l
l = list(1:3, "a string", pi, list(-1, -5))
l
head(l)
l = list(1, 2, 3 "a string", pi, list(-1, -5))
l = list(1, 2, 3, "a string", pi, list(-1, -5))
l
l = list(1, 2, 3, "a string")
l
c(1)  == 1
a = list(c(1:3), "a string", pi, list(-1, -5))
a[4]
a = list(a = c(1:3), b = "a string", c = pi, d = list(-1, -5))
a[4]
a[[4]]
a[[1:4]]
a[1:4]
?factor
